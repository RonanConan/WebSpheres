<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hand Tracking Reaching Experiment</title>
    <meta name="description" content="VR Hand Tracking Experiment for Quest 3">
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@master/examples/showcase/hand-tracking/components/hand-tracking-controls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@master/examples/showcase/hand-tracking/components/hand-tracking-grab-controls.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #score-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Press X to export CSV</div>
    <div id="score-display">Score: 0</div>
    
    <a-scene 
        vr-mode-ui="enabled: true"
        background="color: #212121"
        webxr="requiredFeatures: hand-tracking"
        hand-tracking-controls>
        
        <!-- Assets -->
        <a-assets>
            <a-mixin id="sphere-highlight"
                     geometry="primitive: sphere; radius: 0.04"
                     material="color: red; shader: standard">
            </a-mixin>
        </a-assets>
        
        <!-- Camera rig with hands -->
        <a-entity id="cameraRig" position="0 0 0">
            <a-camera 
                id="camera"
                position="0 1.6 0" 
                look-controls="enabled: false"
                wasd-controls="enabled: false">
            </a-camera>
            
            <!-- Hand entities -->
            <a-entity 
                id="leftHand"
                hand-tracking-controls="hand: left; modelStyle: mesh; modelColor: #fff"
                hand-collision-detector>
            </a-entity>
            
            <a-entity 
                id="rightHand"
                hand-tracking-controls="hand: right; modelStyle: mesh; modelColor: #fff"
                hand-collision-detector>
            </a-entity>
        </a-entity>
        
        <!-- Home position box -->
        <a-box id="home-box" 
               position="0 1.1 -0.1" 
               width="1" 
               height="0.2" 
               depth="0.3" 
               material="color: gray; transparent: true; opacity: 0.7">
        </a-box>
        
        <!-- Target sphere (initially hidden) -->
        <a-sphere id="target-sphere" 
                  mixin="sphere-highlight"
                  visible="false">
        </a-sphere>
        
        <!-- Score popup text -->
        <a-text id="score-popup" 
                value="" 
                position="0 2 -1" 
                align="center" 
                width="6"
                color="yellow"
                visible="false">
        </a-text>
        
        <!-- Thank you message -->
        <a-text id="thank-you" 
                value="Thank you!" 
                position="0 1.6 -1" 
                align="center" 
                width="8"
                color="white"
                visible="false">
        </a-text>
    </a-scene>

    <script>
        // Experiment configuration
        const CONFIG = {
            targetDistance: 1.0, // meters from user
            targetHeight: 1.6,   // eye level
            sphereRadius: 0.04,  // 8cm diameter (4cm radius)
            homeBoxWidth: 1.0,   // 1m wide
            homeBoxPosition: {x: 0, y: 1.1, z: -0.1}, // waist level, 10cm in front
            trialTimeout: 300000, // 300 seconds
            trialsPerTarget: 10,
            totalTargets: 11,
            delayBeforeTarget: 500, // ms
            scorePopupDuration: 500, // ms
            lowScoreRange: [1, 5],
            highScoreRange: [5, 10],
            lowScoreProbability: 0.8
        };

        // Experiment state
        let experimentState = {
            score: 0,
            currentTrial: 0,
            trialsData: [],
            targetCounts: new Array(11).fill(0),
            lastTarget: -1,
            trialStartTime: null,
            handLeftHome: null,
            bothHandsInHome: false,
            targetActive: false,
            waitingForReturn: false,
            experimentComplete: false,
            trialSequence: []
        };

        // Generate trial sequence
        function generateTrialSequence() {
            const sequence = [];
            const targetsNeeded = new Array(11).fill(CONFIG.trialsPerTarget);
            let lastTarget = -1;
            
            while (sequence.length < CONFIG.totalTargets * CONFIG.trialsPerTarget) {
                const availableTargets = [];
                for (let i = 0; i < 11; i++) {
                    if (targetsNeeded[i] > 0 && i !== lastTarget) {
                        availableTargets.push(i);
                    }
                }
                
                if (availableTargets.length === 0) {
                    // If stuck, allow repeat
                    for (let i = 0; i < 11; i++) {
                        if (targetsNeeded[i] > 0) {
                            availableTargets.push(i);
                        }
                    }
                }
                
                const targetIndex = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                sequence.push(targetIndex);
                targetsNeeded[targetIndex]--;
                lastTarget = targetIndex;
            }
            
            return sequence;
        }

        // Calculate target positions
        function getTargetPosition(targetId) {
            const angleStep = Math.PI / (CONFIG.totalTargets - 1); // 180 degrees / 10 steps
            const angle = -Math.PI/2 + (targetId * angleStep); // Start from left (-90Â°)
            
            return {
                x: Math.cos(angle) * CONFIG.targetDistance,
                y: CONFIG.targetHeight,
                z: -Math.sin(angle) * CONFIG.targetDistance
            };
        }

        // Simple audio generation
        function playTone(frequency, duration) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Hand collision detection component
        AFRAME.registerComponent('hand-collision-detector', {
            schema: {},
            
            init: function() {
                this.handTracking = this.el.components['hand-tracking-controls'];
                this.isTracked = false;
                this.hitThisTrial = false;
            },
            
            tick: function() {
                if (!this.handTracking || !experimentState.targetActive || this.hitThisTrial) return;
                
                // Check if hand is tracked
                if (this.handTracking.hand && this.handTracking.hand.visible) {
                    const targetSphere = document.querySelector('#target-sphere');
                    if (!targetSphere.getAttribute('visible')) return;
                    
                    const targetPos = targetSphere.object3D.position;
                    const handPos = this.el.object3D.position;
                    
                    // Check collision
                    const distance = handPos.distanceTo(targetPos);
                    
                    if (distance < CONFIG.sphereRadius + 0.05) { // Add tolerance
                        this.handleTargetHit();
                    }
                }
            },
            
            handleTargetHit: function() {
                if (!experimentState.targetActive || this.hitThisTrial) return;
                
                this.hitThisTrial = true;
                experimentState.targetActive = false;
                const hitTime = Date.now();
                const reactionTime = experimentState.handLeftHome ? 
                    experimentState.handLeftHome - experimentState.trialStartTime : 
                    hitTime - experimentState.trialStartTime;
                
                // Determine score
                const isHighScore = Math.random() > CONFIG.lowScoreProbability;
                const scoreRange = isHighScore ? CONFIG.highScoreRange : CONFIG.lowScoreRange;
                const points = Math.floor(Math.random() * (scoreRange[1] - scoreRange[0] + 1)) + scoreRange[0];
                
                // Update score
                experimentState.score += points;
                document.getElementById('score-display').textContent = `Score: ${experimentState.score}`;
                
                // Show score popup
                const popup = document.querySelector('#score-popup');
                const targetPos = document.querySelector('#target-sphere').getAttribute('position');
                popup.setAttribute('value', `+${points}`);
                popup.setAttribute('position', `${targetPos.x} ${targetPos.y + 0.2} ${targetPos.z}`);
                popup.setAttribute('visible', true);
                
                // Play sound
                playTone(isHighScore ? 880 : 440, isHighScore ? 0.15 : 0.1);
                
                // Change sphere color and hide
                const sphere = document.querySelector('#target-sphere');
                sphere.setAttribute('material', 'color', 'blue');
                
                setTimeout(() => {
                    sphere.setAttribute('visible', false);
                    popup.setAttribute('visible', false);
                    experimentState.waitingForReturn = true;
                    
                    // Reset hit flag for both hands
                    document.querySelectorAll('[hand-collision-detector]').forEach(el => {
                        el.components['hand-collision-detector'].hitThisTrial = false;
                    });
                }, 100);
                
                // Record trial data
                const trialData = {
                    trialNumber: experimentState.currentTrial + 1,
                    targetID: experimentState.trialSequence[experimentState.currentTrial] + 1,
                    handUsed: this.el.getAttribute('hand-tracking-controls').data.hand,
                    timeToOnset: reactionTime
                };
                
                experimentState.trialsData.push(trialData);
                experimentState.currentTrial++;
                
                // Check if experiment is complete
                if (experimentState.currentTrial >= experimentState.trialSequence.length) {
                    endExperiment();
                }
            }
        });

        // Home position tracking
        AFRAME.registerComponent('home-position-tracker', {
            init: function() {
                this.homeBox = document.querySelector('#home-box');
                this.leftHand = document.querySelector('#leftHand');
                this.rightHand = document.querySelector('#rightHand');
                this.trialTimer = null;
            },
            
            tick: function() {
                if (experimentState.experimentComplete) return;
                
                const leftInHome = this.isHandInHome(this.leftHand);
                const rightInHome = this.isHandInHome(this.rightHand);
                const bothInHome = leftInHome && rightInHome;
                
                // Track when hands leave home
                if (experimentState.targetActive && !experimentState.handLeftHome) {
                    if (experimentState.bothHandsInHome && (!leftInHome || !rightInHome)) {
                        experimentState.handLeftHome = Date.now();
                    }
                }
                
                // Update home box color
                this.homeBox.setAttribute('material', 'color', bothInHome ? 'green' : 'gray');
                
                // Handle state transitions
                if (bothInHome && !experimentState.bothHandsInHome) {
                    experimentState.bothHandsInHome = true;
                    
                    if (experimentState.waitingForReturn) {
                        experimentState.waitingForReturn = false;
                        experimentState.handLeftHome = null;
                        
                        // Clear any existing timer
                        if (this.trialTimer) {
                            clearTimeout(this.trialTimer);
                        }
                        
                        // Start next trial after delay
                        this.trialTimer = setTimeout(() => {
                            if (experimentState.bothHandsInHome && !experimentState.experimentComplete) {
                                this.startTrial();
                            }
                        }, CONFIG.delayBeforeTarget);
                    } else if (!experimentState.targetActive && experimentState.currentTrial === 0) {
                        // Start first trial
                        this.trialTimer = setTimeout(() => {
                            if (experimentState.bothHandsInHome && !experimentState.experimentComplete) {
                                this.startTrial();
                            }
                        }, CONFIG.delayBeforeTarget);
                    }
                } else if (!bothInHome && experimentState.bothHandsInHome) {
                    experimentState.bothHandsInHome = false;
                    
                    // Cancel trial start if hands leave home
                    if (this.trialTimer && !experimentState.targetActive) {
                        clearTimeout(this.trialTimer);
                        this.trialTimer = null;
                    }
                }
            },
            
            isHandInHome: function(hand) {
                const handTracking = hand.components['hand-tracking-controls'];
                if (!handTracking || !handTracking.hand || !handTracking.hand.visible) {
                    return false;
                }
                
                const handPos = hand.object3D.position;
                const boxPos = this.homeBox.object3D.position;
                const boxSize = {
                    width: CONFIG.homeBoxWidth,
                    height: 0.2,
                    depth: 0.3
                };
                
                // Check if most of hand is within box bounds
                const margin = 0.05;
                return Math.abs(handPos.x - boxPos.x) < (boxSize.width / 2 - margin) &&
                       Math.abs(handPos.y - boxPos.y) < (boxSize.height / 2 + margin) &&
                       Math.abs(handPos.z - boxPos.z) < (boxSize.depth / 2 + margin);
            },
            
            startTrial: function() {
                if (experimentState.currentTrial >= experimentState.trialSequence.length || 
                    experimentState.experimentComplete) return;
                
                const targetId = experimentState.trialSequence[experimentState.currentTrial];
                const position = getTargetPosition(targetId);
                
                const sphere = document.querySelector('#target-sphere');
                sphere.object3D.position.set(position.x, position.y, position.z);
                sphere.setAttribute('material', 'color', 'red');
                sphere.setAttribute('visible', true);
                
                experimentState.targetActive = true;
                experimentState.trialStartTime = Date.now();
                experimentState.handLeftHome = null;
                
                // Set timeout for trial
                setTimeout(() => {
                    if (experimentState.targetActive) {
                        // Trial timed out
                        experimentState.targetActive = false;
                        sphere.setAttribute('visible', false);
                        experimentState.waitingForReturn = true;
                        
                        // Record timeout
                        experimentState.trialsData.push({
                            trialNumber: experimentState.currentTrial + 1,
                            targetID: targetId + 1,
                            handUsed: 'timeout',
                            timeToOnset: CONFIG.trialTimeout
                        });
                        
                        experimentState.currentTrial++;
                        if (experimentState.currentTrial >= experimentState.trialSequence.length) {
                            endExperiment();
                        }
                    }
                }, CONFIG.trialTimeout);
            }
        });

        function endExperiment() {
            experimentState.experimentComplete = true;
            document.querySelector('#thank-you').setAttribute('visible', true);
            document.querySelector('#target-sphere').setAttribute('visible', false);
            console.log('Experiment complete! Press X to download data.');
        }

        // CSV export
        function exportToCSV() {
            let csv = 'trialNumber,targetID,handUsed,timeToOnset\n';
            experimentState.trialsData.forEach(trial => {
                csv += `${trial.trialNumber},${trial.targetID},${trial.handUsed},${trial.timeToOnset}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hand_tracking_experiment_${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Data exported!');
        }

        // Keyboard listener for CSV export
        document.addEventListener('keydown', (e) => {
            if (e.key === 'x' || e.key === 'X') {
                exportToCSV();
            }
        });

        // Initialize experiment
        document.addEventListener('DOMContentLoaded', () => {
            // Generate trial sequence
            experimentState.trialSequence = generateTrialSequence();
            console.log('Experiment ready. Trial sequence generated:', experimentState.trialSequence.length, 'trials');
            
            // Add home position tracker to scene
            document.querySelector('a-scene').setAttribute('home-position-tracker', '');
        });

        // Debug info
        window.addEventListener('load', () => {
            console.log('Hand Tracking Experiment Loaded');
            console.log('Configuration:', CONFIG);
            console.log('Put both hands in the home box to begin');
        });
    </script>
</body>
</html>
