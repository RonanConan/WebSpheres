<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hand Tracking Reaching Experiment</title>
    <meta name="description" content="VR Hand Tracking Experiment for Quest 3">
    <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@1.4.0/dist/aframe-master.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@1.4.0/examples/showcase/hand-tracking/components/hand-tracking-controls.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #score-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Press X to export CSV</div>
    <div id="score-display">Score: 0</div>
    
    <a-scene background="color: #212121">
        <!-- Camera with hands -->
        <a-entity camera position="0 1.6 0" look-controls="enabled: false">
            <a-entity id="leftHand" 
                      hand-tracking-controls="hand: left; modelStyle: mesh; modelColor: white"
                      hand-tracker>
            </a-entity>
            <a-entity id="rightHand" 
                      hand-tracking-controls="hand: right; modelStyle: mesh; modelColor: white"
                      hand-tracker>
            </a-entity>
        </a-entity>
        
        <!-- Home position box -->
        <a-box id="home-box" 
               position="0 1.1 -0.1" 
               width="1" 
               height="0.2" 
               depth="0.3" 
               color="gray"
               opacity="0.7">
        </a-box>
        
        <!-- Target sphere (initially hidden) -->
        <a-sphere id="target-sphere" 
                  position="0 1.6 -1"
                  radius="0.04"
                  color="red"
                  visible="false">
        </a-sphere>
        
        <!-- Score popup text -->
        <a-text id="score-popup" 
                value="" 
                position="0 2 -1" 
                align="center" 
                width="6"
                color="yellow"
                visible="false">
        </a-text>
        
        <!-- Thank you message -->
        <a-text id="thank-you" 
                value="Thank you!" 
                position="0 1.6 -1" 
                align="center" 
                width="8"
                color="white"
                visible="false">
        </a-text>
        
        <!-- Debug panel -->
        <a-text id="debug" 
                value="Debug: Waiting for hands..." 
                position="-1 2 -2" 
                width="4"
                color="white">
        </a-text>
    </a-scene>

    <script>
        // Experiment configuration
        const CONFIG = {
            targetDistance: 1.0,
            targetHeight: 1.6,
            sphereRadius: 0.04,
            homeBoxWidth: 1.0,
            homeBoxPosition: {x: 0, y: 1.1, z: -0.1},
            trialTimeout: 300000,
            trialsPerTarget: 10,
            totalTargets: 11,
            delayBeforeTarget: 500,
            scorePopupDuration: 500,
            lowScoreRange: [1, 5],
            highScoreRange: [5, 10],
            lowScoreProbability: 0.8
        };

        // Experiment state
        let experimentState = {
            score: 0,
            currentTrial: 0,
            trialsData: [],
            lastTarget: -1,
            trialStartTime: null,
            handLeftHome: null,
            bothHandsInHome: false,
            targetActive: false,
            waitingForReturn: false,
            experimentComplete: false,
            trialSequence: [],
            hitThisTrial: false
        };

        // Generate trial sequence
        function generateTrialSequence() {
            const sequence = [];
            const targetsNeeded = new Array(11).fill(CONFIG.trialsPerTarget);
            let lastTarget = -1;
            
            while (sequence.length < CONFIG.totalTargets * CONFIG.trialsPerTarget) {
                const availableTargets = [];
                for (let i = 0; i < 11; i++) {
                    if (targetsNeeded[i] > 0 && i !== lastTarget) {
                        availableTargets.push(i);
                    }
                }
                
                if (availableTargets.length === 0) {
                    for (let i = 0; i < 11; i++) {
                        if (targetsNeeded[i] > 0) {
                            availableTargets.push(i);
                        }
                    }
                }
                
                const targetIndex = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                sequence.push(targetIndex);
                targetsNeeded[targetIndex]--;
                lastTarget = targetIndex;
            }
            
            return sequence;
        }

        // Calculate target positions
        function getTargetPosition(targetId) {
            const angleStep = Math.PI / (CONFIG.totalTargets - 1);
            const angle = -Math.PI/2 + (targetId * angleStep);
            
            return {
                x: Math.cos(angle) * CONFIG.targetDistance,
                y: CONFIG.targetHeight,
                z: -Math.sin(angle) * CONFIG.targetDistance
            };
        }

        // Hand tracker component
        AFRAME.registerComponent('hand-tracker', {
            init: function() {
                this.el.addEventListener('model-loaded', () => {
                    console.log('Hand model loaded for', this.el.id);
                });
                this.tick = AFRAME.utils.throttleTick(this.tick, 100, this);
            },
            
            tick: function() {
                const hand = this.el.components['hand-tracking-controls'];
                if (!hand || !hand.mesh || !hand.mesh.visible) return;
                
                const handPos = this.el.object3D.position;
                const homeBox = document.querySelector('#home-box');
                const homePos = homeBox.object3D.position;
                
                // Check if in home position
                const inHome = this.isInHome(handPos, homePos);
                
                // Update home tracking
                const isLeft = this.el.id === 'leftHand';
                const otherHand = document.querySelector(isLeft ? '#rightHand' : '#leftHand');
                const otherTracker = otherHand.components['hand-tracker'];
                
                const bothInHome = inHome && otherTracker && otherTracker.isInHome(
                    otherHand.object3D.position, 
                    homePos
                );
                
                // Update home box color
                if (bothInHome !== experimentState.bothHandsInHome) {
                    experimentState.bothHandsInHome = bothInHome;
                    homeBox.setAttribute('color', bothInHome ? 'green' : 'gray');
                    
                    if (bothInHome) {
                        this.handleBothHandsInHome();
                    } else if (experimentState.targetActive && !experimentState.handLeftHome) {
                        experimentState.handLeftHome = Date.now();
                    }
                }
                
                // Check collision with target
                if (experimentState.targetActive && !experimentState.hitThisTrial) {
                    const target = document.querySelector('#target-sphere');
                    if (target.getAttribute('visible')) {
                        const targetPos = target.object3D.position;
                        const distance = handPos.distanceTo(targetPos);
                        
                        if (distance < CONFIG.sphereRadius + 0.05) {
                            this.handleTargetHit();
                        }
                    }
                }
                
                // Update debug
                document.querySelector('#debug').setAttribute('value', 
                    `L: ${inHome} R: ${otherTracker?.isInHome(otherHand.object3D.position, homePos)} ` +
                    `Both: ${bothInHome} Active: ${experimentState.targetActive}`
                );
            },
            
            isInHome: function(handPos, homePos) {
                const margin = 0.05;
                return Math.abs(handPos.x - homePos.x) < (CONFIG.homeBoxWidth / 2 - margin) &&
                       Math.abs(handPos.y - homePos.y) < (0.2 / 2 + margin) &&
                       Math.abs(handPos.z - homePos.z) < (0.3 / 2 + margin);
            },
            
            handleBothHandsInHome: function() {
                if (experimentState.waitingForReturn) {
                    experimentState.waitingForReturn = false;
                    experimentState.handLeftHome = null;
                    experimentState.hitThisTrial = false;
                    
                    setTimeout(() => {
                        if (experimentState.bothHandsInHome) {
                            this.startTrial();
                        }
                    }, CONFIG.delayBeforeTarget);
                } else if (!experimentState.targetActive && experimentState.currentTrial === 0) {
                    setTimeout(() => {
                        if (experimentState.bothHandsInHome) {
                            this.startTrial();
                        }
                    }, CONFIG.delayBeforeTarget);
                }
            },
            
            startTrial: function() {
                if (experimentState.currentTrial >= experimentState.trialSequence.length || 
                    experimentState.experimentComplete || experimentState.targetActive) return;
                
                const targetId = experimentState.trialSequence[experimentState.currentTrial];
                const position = getTargetPosition(targetId);
                
                const sphere = document.querySelector('#target-sphere');
                sphere.object3D.position.set(position.x, position.y, position.z);
                sphere.setAttribute('color', 'red');
                sphere.setAttribute('visible', true);
                
                experimentState.targetActive = true;
                experimentState.trialStartTime = Date.now();
                experimentState.handLeftHome = null;
                experimentState.hitThisTrial = false;
                
                setTimeout(() => {
                    if (experimentState.targetActive) {
                        this.handleTimeout();
                    }
                }, CONFIG.trialTimeout);
            },
            
            handleTargetHit: function() {
                if (!experimentState.targetActive || experimentState.hitThisTrial) return;
                
                experimentState.hitThisTrial = true;
                experimentState.targetActive = false;
                
                const reactionTime = experimentState.handLeftHome ? 
                    experimentState.handLeftHome - experimentState.trialStartTime : 
                    Date.now() - experimentState.trialStartTime;
                
                // Score calculation
                const isHighScore = Math.random() > CONFIG.lowScoreProbability;
                const scoreRange = isHighScore ? CONFIG.highScoreRange : CONFIG.lowScoreRange;
                const points = Math.floor(Math.random() * (scoreRange[1] - scoreRange[0] + 1)) + scoreRange[0];
                
                experimentState.score += points;
                document.getElementById('score-display').textContent = `Score: ${experimentState.score}`;
                
                // Visual feedback
                const sphere = document.querySelector('#target-sphere');
                const popup = document.querySelector('#score-popup');
                const pos = sphere.object3D.position;
                
                sphere.setAttribute('color', 'blue');
                popup.setAttribute('value', `+${points}`);
                popup.object3D.position.set(pos.x, pos.y + 0.2, pos.z);
                popup.setAttribute('visible', true);
                
                this.playTone(isHighScore ? 880 : 440, isHighScore ? 0.15 : 0.1);
                
                setTimeout(() => {
                    sphere.setAttribute('visible', false);
                    popup.setAttribute('visible', false);
                    experimentState.waitingForReturn = true;
                }, 100);
                
                // Record data
                experimentState.trialsData.push({
                    trialNumber: experimentState.currentTrial + 1,
                    targetID: experimentState.trialSequence[experimentState.currentTrial] + 1,
                    handUsed: this.el.id === 'leftHand' ? 'left' : 'right',
                    timeToOnset: reactionTime
                });
                
                experimentState.currentTrial++;
                
                if (experimentState.currentTrial >= experimentState.trialSequence.length) {
                    this.endExperiment();
                }
            },
            
            handleTimeout: function() {
                experimentState.targetActive = false;
                document.querySelector('#target-sphere').setAttribute('visible', false);
                experimentState.waitingForReturn = true;
                
                experimentState.trialsData.push({
                    trialNumber: experimentState.currentTrial + 1,
                    targetID: experimentState.trialSequence[experimentState.currentTrial] + 1,
                    handUsed: 'timeout',
                    timeToOnset: CONFIG.trialTimeout
                });
                
                experimentState.currentTrial++;
                if (experimentState.currentTrial >= experimentState.trialSequence.length) {
                    this.endExperiment();
                }
            },
            
            endExperiment: function() {
                experimentState.experimentComplete = true;
                document.querySelector('#thank-you').setAttribute('visible', true);
                console.log('Experiment complete! Press X to download data.');
            },
            
            playTone: function(freq, duration) {
                try {
                    const ctx = new AudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                    osc.start();
                    osc.stop(ctx.currentTime + duration);
                } catch(e) {}
            }
        });

        // CSV export
        function exportToCSV() {
            let csv = 'trialNumber,targetID,handUsed,timeToOnset\n';
            experimentState.trialsData.forEach(trial => {
                csv += `${trial.trialNumber},${trial.targetID},${trial.handUsed},${trial.timeToOnset}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hand_tracking_experiment_${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'x' || e.key === 'X') {
                exportToCSV();
            }
        });

        // Initialize
        window.addEventListener('load', () => {
            experimentState.trialSequence = generateTrialSequence();
            console.log('Experiment ready with', experimentState.trialSequence.length, 'trials');
        });
    </script>
</body>
</html>
