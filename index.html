<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>VR Reaching Task</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.0/aframe-ar.js"></script>
</head>
<body>
    <a-scene vr-mode-ui="enabled: true" device-orientation-permission-ui="enabled: true">
        <!-- Assets -->
        <a-assets>
        </a-assets>

        <!-- Environment -->
        <a-sky color="#000011"></a-sky>
        <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#222" opacity="0.5"></a-plane>

        <!-- Score Display -->
        <a-text id="score" position="0 2.5 -2" align="center" value="Score: 0" color="white" scale="2 2 2"></a-text>
        <a-text id="status" position="0 2 -2" align="center" value="Place both hands in home position" color="yellow" scale="1 1 1"></a-text>

        <!-- Home Position Box -->
        <a-box id="homeBox" position="0 0.8 -0.1" width="1" height="0.3" depth="0.3" color="grey" opacity="0.5"></a-box>

        <!-- Target Sphere (hidden initially) -->
        <a-sphere id="targetSphere" position="0 1.5 -1" radius="0.04" color="red" visible="false"></a-sphere>

        <!-- Floating Score Display -->
        <a-text id="floatingScore" position="0 1.8 -1" align="center" value="" color="white" visible="false"></a-text>

        <!-- Hand tracking -->
        <a-entity id="leftHand" hand-tracking-controls="hand: left; modelStyle: mesh" visible="true"></a-entity>
        <a-entity id="rightHand" hand-tracking-controls="hand: right; modelStyle: mesh" visible="true"></a-entity>

        <!-- Camera -->
        <a-camera position="0 1.6 0" wasd-controls="enabled: false"></a-camera>
    </a-scene>

    <script>
        // Game state
        let gameState = {
            score: 0,
            currentTrial: 0,
            totalTrials: 110,
            trialsPerTarget: 10,
            targetPositions: [],
            currentTarget: -1,
            trialData: [],
            sphereAppearTime: 0,
            lastTarget: -1,
            bothHandsHome: false,
            waitingForHands: true,
            gameComplete: false
        };

        // Audio context for sounds
        let audioContext;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone(frequency, duration) {
            initAudio();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Initialize target positions in 180-degree arc
        function initializeTargets() {
            const distance = 1.0; // 1m away
            const eyeLevel = 1.5; // eye level height
            
            for (let i = 0; i < 11; i++) {
                const angle = (i - 5) * (Math.PI / 10); // -90 to +90 degrees in radians
                const x = Math.sin(angle) * distance;
                const z = -Math.cos(angle) * distance;
                gameState.targetPositions.push({
                    x: x,
                    y: eyeLevel,
                    z: z
                });
            }
        }

        // Check if both hands are in home position
        function checkHandsInHome() {
            const leftHand = document.querySelector('#leftHand');
            const rightHand = document.querySelector('#rightHand');
            const homeBox = document.querySelector('#homeBox');
            
            if (!leftHand || !rightHand || !homeBox) return false;
            
            const leftPos = leftHand.getAttribute('position');
            const rightPos = rightHand.getAttribute('position');
            const homePos = homeBox.getAttribute('position');
            
            if (!leftPos || !rightPos) return false;
            
            // Check if hands are within home box bounds
            const homeSize = { x: 1, y: 0.3, z: 0.3 };
            
            const leftInHome = Math.abs(leftPos.x - homePos.x) < homeSize.x/2 &&
                              Math.abs(leftPos.y - homePos.y) < homeSize.y/2 &&
                              Math.abs(leftPos.z - homePos.z) < homeSize.z/2;
                              
            const rightInHome = Math.abs(rightPos.x - homePos.x) < homeSize.x/2 &&
                               Math.abs(rightPos.y - homePos.y) < homeSize.y/2 &&
                               Math.abs(rightPos.z - homePos.z) < homeSize.z/2;
            
            return leftInHome && rightInHome;
        }

        // Get next target (pseudo-random, no repeats)
        function getNextTarget() {
            let nextTarget;
            do {
                nextTarget = Math.floor(Math.random() * 11);
            } while (nextTarget === gameState.lastTarget);
            
            gameState.lastTarget = nextTarget;
            return nextTarget;
        }

        // Show target sphere
        function showTarget() {
            if (gameState.gameComplete) return;
            
            const targetIndex = getNextTarget();
            const targetPos = gameState.targetPositions[targetIndex];
            const sphere = document.querySelector('#targetSphere');
            
            sphere.setAttribute('position', `${targetPos.x} ${targetPos.y} ${targetPos.z}`);
            sphere.setAttribute('color', 'red');
            sphere.setAttribute('visible', 'true');
            
            gameState.currentTarget = targetIndex;
            gameState.sphereAppearTime = Date.now();
            gameState.waitingForHands = false;
            
            document.querySelector('#status').setAttribute('value', 'Reach for the red sphere!');
        }

        // Handle sphere hit
        function onSphereHit(hand) {
            if (gameState.currentTarget === -1) return;
            
            const timeToOnset = Date.now() - gameState.sphereAppearTime;
            
            // Determine points (80% low range, 20% high range)
            const isHighRange = Math.random() < 0.2;
            let points;
            if (isHighRange) {
                points = Math.floor(Math.random() * 6) + 5; // 5-10
                playTone(800, 0.2); // High ding
            } else {
                points = Math.floor(Math.random() * 5) + 1; // 1-5
                playTone(400, 0.2); // Low boop
            }
            
            gameState.score += points;
            gameState.currentTrial++;
            
            // Record trial data
            gameState.trialData.push({
                trial_number: gameState.currentTrial,
                target_id: gameState.currentTarget + 1, // 1-indexed
                hand_used: hand,
                time_to_onset: timeToOnset,
                points_scored: points,
                timestamp: new Date().toISOString()
            });
            
            // Update displays
            document.querySelector('#score').setAttribute('value', `Score: ${gameState.score}`);
            
            const floatingScore = document.querySelector('#floatingScore');
            const sphere = document.querySelector('#targetSphere');
            const spherePos = sphere.getAttribute('position');
            floatingScore.setAttribute('position', `${spherePos.x} ${spherePos.y + 0.2} ${spherePos.z}`);
            floatingScore.setAttribute('value', `+${points}`);
            floatingScore.setAttribute('visible', 'true');
            
            // Hide floating score after 0.5 seconds
            setTimeout(() => {
                floatingScore.setAttribute('visible', 'false');
            }, 500);
            
            // Change sphere to blue then hide
            sphere.setAttribute('color', 'blue');
            setTimeout(() => {
                sphere.setAttribute('visible', 'false');
                gameState.currentTarget = -1;
                
                if (gameState.currentTrial >= gameState.totalTrials) {
                    // Game complete
                    gameState.gameComplete = true;
                    document.querySelector('#status').setAttribute('value', 'Thank you!');
                    document.querySelector('#homeBox').setAttribute('color', 'green');
                } else {
                    gameState.waitingForHands = true;
                    document.querySelector('#status').setAttribute('value', 'Return to home position');
                }
            }, 200);
        }

        // Check for sphere collision
        function checkSphereCollision() {
            if (gameState.currentTarget === -1) return;
            
            const sphere = document.querySelector('#targetSphere');
            const leftHand = document.querySelector('#leftHand');
            const rightHand = document.querySelector('#rightHand');
            
            if (!sphere.getAttribute('visible')) return;
            
            const spherePos = sphere.getAttribute('position');
            const sphereRadius = 0.04;
            
            [leftHand, rightHand].forEach((hand, index) => {
                const handPos = hand.getAttribute('position');
                if (!handPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(handPos.x - spherePos.x, 2) +
                    Math.pow(handPos.y - spherePos.y, 2) +
                    Math.pow(handPos.z - spherePos.z, 2)
                );
                
                if (distance < sphereRadius + 0.05) { // Hand collision radius
                    onSphereHit(index === 0 ? 'left' : 'right');
                }
            });
        }

        // Main game loop
        function gameLoop() {
            if (gameState.gameComplete) return;
            
            const handsInHome = checkHandsInHome();
            const homeBox = document.querySelector('#homeBox');
            
            // Update home box color
            if (handsInHome) {
                homeBox.setAttribute('color', 'green');
                if (gameState.waitingForHands && !gameState.bothHandsHome) {
                    gameState.bothHandsHome = true;
                    // Start trial after 0.5 second delay
                    setTimeout(() => {
                        if (gameState.bothHandsHome && checkHandsInHome()) {
                            showTarget();
                        }
                    }, 500);
                }
            } else {
                homeBox.setAttribute('color', 'grey');
                gameState.bothHandsHome = false;
            }
            
            // Check for sphere collision
            checkSphereCollision();
            
            requestAnimationFrame(gameLoop);
        }

        // Download CSV function
        function downloadCSV() {
            if (gameState.trialData.length === 0) return;
            
            const headers = ['trial_number', 'target_id', 'hand_used', 'time_to_onset', 'points_scored', 'timestamp'];
            let csvContent = headers.join(',') + '\n';
            
            gameState.trialData.forEach(row => {
                csvContent += headers.map(header => row[header]).join(',') + '\n';
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'reaching_task_data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // Keyboard event listener
        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'x') {
                downloadCSV();
            }
        });

        // Initialize when scene loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeTargets();
            setTimeout(() => {
                gameLoop();
            }, 1000);
        });
    </script>
</body>
</html>
