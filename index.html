<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hand Tracking Reaching Experiment</title>
    <meta name="description" content="VR Hand Tracking Experiment for Quest 3">
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #score-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Press X to export CSV | Status: <span id="status">Loading...</span></div>
    <div id="score-display">Score: 0</div>
    
    <a-scene 
        vr-mode-ui="enabled: true"
        background="color: #212121"
        webxr="optionalFeatures: hand-tracking"
        stats>
        
        <!-- Camera rig -->
        <a-entity id="cameraRig">
            <a-camera 
                id="camera"
                position="0 1.6 0" 
                look-controls="enabled: false"
                wasd-controls="enabled: false">
            </a-camera>
        </a-entity>
        
        <!-- Hands will be created dynamically -->
        
        <!-- Home position box -->
        <a-box id="home-box" 
               position="0 1.1 -0.1" 
               width="1" 
               height="0.2" 
               depth="0.3" 
               color="gray"
               opacity="0.7">
        </a-box>
        
        <!-- Target sphere (initially hidden) -->
        <a-sphere id="target-sphere" 
                  position="0 1.6 -1"
                  radius="0.04"
                  color="red"
                  visible="false">
        </a-sphere>
        
        <!-- Score popup text -->
        <a-text id="score-popup" 
                value="" 
                position="0 2 -1" 
                align="center" 
                width="6"
                color="yellow"
                visible="false">
        </a-text>
        
        <!-- Thank you message -->
        <a-text id="thank-you" 
                value="Thank you!" 
                position="0 1.6 -1" 
                align="center" 
                width="8"
                color="white"
                visible="false">
        </a-text>
    </a-scene>

    <script>
        // Status updates
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('Status:', message);
        }

        // Experiment configuration
        const CONFIG = {
            targetDistance: 1.0,
            targetHeight: 1.6,
            sphereRadius: 0.04,
            homeBoxWidth: 1.0,
            homeBoxPosition: {x: 0, y: 1.1, z: -0.1},
            trialTimeout: 300000,
            trialsPerTarget: 10,
            totalTargets: 11,
            delayBeforeTarget: 500,
            scorePopupDuration: 500,
            lowScoreRange: [1, 5],
            highScoreRange: [5, 10],
            lowScoreProbability: 0.8
        };

        // Experiment state
        let experimentState = {
            score: 0,
            currentTrial: 0,
            trialsData: [],
            targetCounts: new Array(11).fill(0),
            lastTarget: -1,
            trialStartTime: null,
            handLeftHome: null,
            bothHandsInHome: false,
            targetActive: false,
            waitingForReturn: false,
            experimentComplete: false,
            trialSequence: [],
            leftHandTracked: false,
            rightHandTracked: false,
            vrActive: false
        };

        // Hand tracking using WebXR directly
        let xrSession = null;
        let leftHandMesh = null;
        let rightHandMesh = null;
        let referenceSpace = null;

        // Create hand meshes
        function createHandMesh() {
            const geometry = new THREE.BoxGeometry(0.08, 0.02, 0.12);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8 
            });
            return new THREE.Mesh(geometry, material);
        }

        // Initialize WebXR
        async function initXR() {
            updateStatus('Initializing XR...');
            
            const scene = document.querySelector('a-scene');
            
            scene.addEventListener('enter-vr', async () => {
                updateStatus('Entering VR...');
                experimentState.vrActive = true;
                
                // Get the XR session
                if (scene.xrSession) {
                    xrSession = scene.xrSession;
                    
                    try {
                        // Request hand tracking
                        referenceSpace = await xrSession.requestReferenceSpace('local');
                        
                        updateStatus('VR Active - Place hands in home box');
                        
                        // Create hand meshes
                        leftHandMesh = createHandMesh();
                        rightHandMesh = createHandMesh();
                        
                        scene.object3D.add(leftHandMesh);
                        scene.object3D.add(rightHandMesh);
                        
                        // Start the experiment loop
                        startExperimentLoop();
                    } catch (e) {
                        updateStatus('Hand tracking error: ' + e.message);
                        console.error('Hand tracking initialization error:', e);
                    }
                }
            });
            
            scene.addEventListener('exit-vr', () => {
                updateStatus('Exited VR');
                experimentState.vrActive = false;
                xrSession = null;
            });
        }

        // Generate trial sequence
        function generateTrialSequence() {
            const sequence = [];
            const targetsNeeded = new Array(11).fill(CONFIG.trialsPerTarget);
            let lastTarget = -1;
            
            while (sequence.length < CONFIG.totalTargets * CONFIG.trialsPerTarget) {
                const availableTargets = [];
                for (let i = 0; i < 11; i++) {
                    if (targetsNeeded[i] > 0 && i !== lastTarget) {
                        availableTargets.push(i);
                    }
                }
                
                if (availableTargets.length === 0) {
                    for (let i = 0; i < 11; i++) {
                        if (targetsNeeded[i] > 0) {
                            availableTargets.push(i);
                        }
                    }
                }
                
                const targetIndex = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                sequence.push(targetIndex);
                targetsNeeded[targetIndex]--;
                lastTarget = targetIndex;
            }
            
            return sequence;
        }

        // Calculate target positions
        function getTargetPosition(targetId) {
            const angleStep = Math.PI / (CONFIG.totalTargets - 1);
            const angle = -Math.PI/2 + (targetId * angleStep);
            
            return {
                x: Math.cos(angle) * CONFIG.targetDistance,
                y: CONFIG.targetHeight,
                z: -Math.sin(angle) * CONFIG.targetDistance
            };
        }

        // Check if hand is in home position
        function isHandInHome(handPosition) {
            if (!handPosition) return false;
            
            const boxPos = CONFIG.homeBoxPosition;
            const boxSize = {
                width: CONFIG.homeBoxWidth,
                height: 0.2,
                depth: 0.3
            };
            
            const margin = 0.05;
            return Math.abs(handPosition.x - boxPos.x) < (boxSize.width / 2 - margin) &&
                   Math.abs(handPosition.y - boxPos.y) < (boxSize.height / 2 + margin) &&
                   Math.abs(handPosition.z - boxPos.z) < (boxSize.depth / 2 + margin);
        }

        // Check collision with target
        function checkTargetCollision(handPosition) {
            if (!experimentState.targetActive || !handPosition) return false;
            
            const sphere = document.querySelector('#target-sphere');
            const targetPos = sphere.object3D.position;
            
            const distance = Math.sqrt(
                Math.pow(handPosition.x - targetPos.x, 2) +
                Math.pow(handPosition.y - targetPos.y, 2) +
                Math.pow(handPosition.z - targetPos.z, 2)
            );
            
            return distance < CONFIG.sphereRadius + 0.05;
        }

        // Handle target hit
        function handleTargetHit(hand) {
            if (!experimentState.targetActive) return;
            
            experimentState.targetActive = false;
            const hitTime = Date.now();
            const reactionTime = experimentState.handLeftHome ? 
                experimentState.handLeftHome - experimentState.trialStartTime : 
                hitTime - experimentState.trialStartTime;
            
            // Determine score
            const isHighScore = Math.random() > CONFIG.lowScoreProbability;
            const scoreRange = isHighScore ? CONFIG.highScoreRange : CONFIG.lowScoreRange;
            const points = Math.floor(Math.random() * (scoreRange[1] - scoreRange[0] + 1)) + scoreRange[0];
            
            // Update score
            experimentState.score += points;
            document.getElementById('score-display').textContent = `Score: ${experimentState.score}`;
            
            // Show score popup
            const popup = document.querySelector('#score-popup');
            const sphere = document.querySelector('#target-sphere');
            const targetPos = sphere.object3D.position;
            popup.setAttribute('value', `+${points}`);
            popup.object3D.position.set(targetPos.x, targetPos.y + 0.2, targetPos.z);
            popup.setAttribute('visible', true);
            
            // Play sound
            playTone(isHighScore ? 880 : 440, isHighScore ? 0.15 : 0.1);
            
            // Change sphere color and hide
            sphere.setAttribute('color', 'blue');
            
            setTimeout(() => {
                sphere.setAttribute('visible', false);
                popup.setAttribute('visible', false);
                experimentState.waitingForReturn = true;
            }, 100);
            
            // Record trial data
            const trialData = {
                trialNumber: experimentState.currentTrial + 1,
                targetID: experimentState.trialSequence[experimentState.currentTrial] + 1,
                handUsed: hand,
                timeToOnset: reactionTime
            };
            
            experimentState.trialsData.push(trialData);
            experimentState.currentTrial++;
            
            // Check if experiment is complete
            if (experimentState.currentTrial >= experimentState.trialSequence.length) {
                endExperiment();
            }
        }

        // Start trial
        function startTrial() {
            if (experimentState.currentTrial >= experimentState.trialSequence.length || 
                experimentState.experimentComplete) return;
            
            const targetId = experimentState.trialSequence[experimentState.currentTrial];
            const position = getTargetPosition(targetId);
            
            const sphere = document.querySelector('#target-sphere');
            sphere.object3D.position.set(position.x, position.y, position.z);
            sphere.setAttribute('color', 'red');
            sphere.setAttribute('visible', true);
            
            experimentState.targetActive = true;
            experimentState.trialStartTime = Date.now();
            experimentState.handLeftHome = null;
            
            updateStatus(`Trial ${experimentState.currentTrial + 1}/${experimentState.trialSequence.length}`);
            
            // Set timeout
            setTimeout(() => {
                if (experimentState.targetActive) {
                    experimentState.targetActive = false;
                    sphere.setAttribute('visible', false);
                    experimentState.waitingForReturn = true;
                    
                    experimentState.trialsData.push({
                        trialNumber: experimentState.currentTrial + 1,
                        targetID: targetId + 1,
                        handUsed: 'timeout',
                        timeToOnset: CONFIG.trialTimeout
                    });
                    
                    experimentState.currentTrial++;
                    if (experimentState.currentTrial >= experimentState.trialSequence.length) {
                        endExperiment();
                    }
                }
            }, CONFIG.trialTimeout);
        }

        // Main experiment loop
        let trialStartTimer = null;
        
        function startExperimentLoop() {
            const scene = document.querySelector('a-scene');
            const homeBox = document.querySelector('#home-box');
            
            function updateLoop(timestamp, frame) {
                if (!experimentState.vrActive || !frame) return;
                
                // Get hand poses
                const leftHandPose = frame.getJointPose ? 
                    frame.getJointPose(frame.session.inputSources[0]?.hand?.get('wrist'), referenceSpace) : null;
                const rightHandPose = frame.getJointPose ? 
                    frame.getJointPose(frame.session.inputSources[1]?.hand?.get('wrist'), referenceSpace) : null;
                
                // Fallback to simple input source tracking
                let leftPos = null, rightPos = null;
                
                if (frame.session.inputSources) {
                    frame.session.inputSources.forEach(inputSource => {
                        if (inputSource.handedness === 'left' && inputSource.gripSpace) {
                            const pose = frame.getPose(inputSource.gripSpace, referenceSpace);
                            if (pose) {
                                leftPos = {
                                    x: pose.transform.position.x,
                                    y: pose.transform.position.y,
                                    z: pose.transform.position.z
                                };
                                leftHandMesh.position.set(leftPos.x, leftPos.y, leftPos.z);
                                leftHandMesh.visible = true;
                                experimentState.leftHandTracked = true;
                            }
                        } else if (inputSource.handedness === 'right' && inputSource.gripSpace) {
                            const pose = frame.getPose(inputSource.gripSpace, referenceSpace);
                            if (pose) {
                                rightPos = {
                                    x: pose.transform.position.x,
                                    y: pose.transform.position.y,
                                    z: pose.transform.position.z
                                };
                                rightHandMesh.position.set(rightPos.x, rightPos.y, rightPos.z);
                                rightHandMesh.visible = true;
                                experimentState.rightHandTracked = true;
                            }
                        }
                    });
                }
                
                // Check home position
                const leftInHome = isHandInHome(leftPos);
                const rightInHome = isHandInHome(rightPos);
                const bothInHome = leftInHome && rightInHome;
                
                // Update home box color
                homeBox.setAttribute('color', bothInHome ? 'green' : 'gray');
                
                // Track when hands leave home
                if (experimentState.targetActive && !experimentState.handLeftHome) {
                    if (experimentState.bothHandsInHome && (!leftInHome || !rightInHome)) {
                        experimentState.handLeftHome = Date.now();
                    }
                }
                
                // Check for target collision
                if (experimentState.targetActive) {
                    if (checkTargetCollision(leftPos)) {
                        handleTargetHit('left');
                    } else if (checkTargetCollision(rightPos)) {
                        handleTargetHit('right');
                    }
                }
                
                // Handle state transitions
                if (bothInHome && !experimentState.bothHandsInHome) {
                    experimentState.bothHandsInHome = true;
                    
                    if (experimentState.waitingForReturn) {
                        experimentState.waitingForReturn = false;
                        experimentState.handLeftHome = null;
                        
                        if (trialStartTimer) clearTimeout(trialStartTimer);
                        trialStartTimer = setTimeout(() => {
                            if (experimentState.bothHandsInHome && !experimentState.experimentComplete) {
                                startTrial();
                            }
                        }, CONFIG.delayBeforeTarget);
                    } else if (!experimentState.targetActive && experimentState.currentTrial === 0) {
                        if (trialStartTimer) clearTimeout(trialStartTimer);
                        trialStartTimer = setTimeout(() => {
                            if (experimentState.bothHandsInHome && !experimentState.experimentComplete) {
                                startTrial();
                            }
                        }, CONFIG.delayBeforeTarget);
                    }
                } else if (!bothInHome && experimentState.bothHandsInHome) {
                    experimentState.bothHandsInHome = false;
                    if (trialStartTimer && !experimentState.targetActive) {
                        clearTimeout(trialStartTimer);
                        trialStartTimer = null;
                    }
                }
            }
            
            // Use A-Frame's render loop
            scene.renderer.xr.enabled = true;
            scene.renderer.setAnimationLoop(updateLoop);
        }

        // Audio generation
        function playTone(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('Audio error:', e);
            }
        }

        // End experiment
        function endExperiment() {
            experimentState.experimentComplete = true;
            document.querySelector('#thank-you').setAttribute('visible', true);
            document.querySelector('#target-sphere').setAttribute('visible', false);
            updateStatus('Experiment complete! Press X to download data.');
        }

        // CSV export
        function exportToCSV() {
            let csv = 'trialNumber,targetID,handUsed,timeToOnset\n';
            experimentState.trialsData.forEach(trial => {
                csv += `${trial.trialNumber},${trial.targetID},${trial.handUsed},${trial.timeToOnset}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hand_tracking_experiment_${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Data exported!');
        }

        // Keyboard listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'x' || e.key === 'X') {
                exportToCSV();
            }
        });

        // Initialize
        window.addEventListener('load', () => {
            updateStatus('Page loaded, initializing...');
            
            // Generate trial sequence
            experimentState.trialSequence = generateTrialSequence();
            console.log('Generated', experimentState.trialSequence.length, 'trials');
            
            // Wait for A-Frame to initialize
            const scene = document.querySelector('a-scene');
            if (scene.hasLoaded) {
                initXR();
            } else {
                scene.addEventListener('loaded', initXR);
            }
        });
    </script>
</body>
</html>
